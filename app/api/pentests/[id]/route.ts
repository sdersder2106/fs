import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth, requirePentester } from '@/lib/auth-helpers';
import { 
  successResponse, 
  errorResponse, 
  unauthorizedResponse,
  forbiddenResponse,
  notFoundResponse,
  updatedResponse,
  deletedResponse
} from '@/lib/api-response';
import { updatePentestSchema } from '@/lib/validations';
import { notificationTemplates, notifyPentestTeam } from '@/lib/notifications';

interface RouteParams {
  params: { id: string };
}

// GET /api/pentests/[id] - Get single pentest with details
export async function GET(request: NextRequest, { params }: RouteParams) {
  try {
    const user = await requireAuth();
    const { id } = params;

    const pentest = await prisma.pentest.findFirst({
      where: { 
        id,
        companyId: user.companyId,
      },
      include: {
        target: true,
        createdBy: {
          select: {
            id: true,
            fullName: true,
            email: true,
            avatar: true,
            role: true,
          },
        },
        findings: {
          orderBy: { severity: 'asc' },
          include: {
            reporter: {
              select: {
                id: true,
                fullName: true,
                email: true,
                avatar: true,
              },
            },
            assignedTo: {
              select: {
                id: true,
                fullName: true,
                email: true,
                avatar: true,
              },
            },
            _count: {
              select: {
                comments: true,
              },
            },
          },
        },
        reports: {
          orderBy: { createdAt: 'desc' },
          include: {
            generator: {
              select: {
                id: true,
                fullName: true,
                email: true,
              },
            },
          },
        },
        comments: {
          orderBy: { createdAt: 'desc' },
          take: 10,
          include: {
            author: {
              select: {
                id: true,
                fullName: true,
                email: true,
                avatar: true,
                role: true,
              },
            },
          },
        },
        _count: {
          select: {
            findings: true,
            reports: true,
            comments: true,
          },
        },
      },
    });

    if (!pentest) {
      return notFoundResponse('Pentest');
    }

    // Calculate statistics
    const findingsBySeverity = {
      CRITICAL: 0,
      HIGH: 0,
      MEDIUM: 0,
      LOW: 0,
      INFO: 0,
    };

    const findingsByStatus = {
      OPEN: 0,
      IN_PROGRESS: 0,
      RESOLVED: 0,
      CLOSED: 0,
    };

    pentest.findings.forEach(finding => {
      findingsBySeverity[finding.severity as keyof typeof findingsBySeverity]++;
      findingsByStatus[finding.status as keyof typeof findingsByStatus]++;
    });

    // Format response
    const responseData = {
      ...pentest,
      statistics: {
        totalFindings: pentest._count.findings,
        findingsBySeverity,
        findingsByStatus,
        totalReports: pentest._count.reports,
        totalComments: pentest._count.comments,
        completionRate: pentest.progress,
      },
    };

    return successResponse(responseData);
  } catch (error) {
    console.error('Error fetching pentest:', error);
    
    if (error instanceof Error) {
      if (error.message === 'Unauthorized') {
        return unauthorizedResponse();
      }
    }
    
    return errorResponse('Failed to fetch pentest', 500);
  }
}

// PUT /api/pentests/[id] - Update pentest
export async function PUT(request: NextRequest, { params }: RouteParams) {
  try {
    const user = await requirePentester();
    const { id } = params;
    const body = await request.json();
    
    // Validate input
    const validationResult = updatePentestSchema.safeParse({ ...body, id });
    
    if (!validationResult.success) {
      return errorResponse(validationResult.error, 400);
    }

    // Check if pentest exists and user has access
    const existingPentest = await prisma.pentest.findFirst({
      where: { 
        id,
        companyId: user.companyId,
      },
    });

    if (!existingPentest) {
      return notFoundResponse('Pentest');
    }

    // Only creator and admins can update
    if (existingPentest.createdById !== user.id && user.role !== 'ADMIN') {
      return forbiddenResponse('Only the creator or admins can update this pentest');
    }

    const {
      title,
      description,
      status,
      progress,
      startDate,
      endDate,
      methodology,
      targetId,
    } = validationResult.data;

    // If changing target, verify it exists and belongs to company
    if (targetId && targetId !== existingPentest.targetId) {
      const target = await prisma.target.findFirst({
        where: {
          id: targetId,
          companyId: user.companyId,
        },
      });

      if (!target) {
        return errorResponse('Target not found or access denied', 404);
      }
    }

    // Track status changes for notifications
    const statusChanged = status && status !== existingPentest.status;
    const wasCompleted = statusChanged && status === 'COMPLETED';
    const wasStarted = statusChanged && existingPentest.status === 'SCHEDULED' && status === 'IN_PROGRESS';

    // Update pentest
    const updatedPentest = await prisma.pentest.update({
      where: { id },
      data: {
        ...(title && { title }),
        ...(description !== undefined && { description }),
        ...(status && { status }),
        ...(progress !== undefined && { progress }),
        ...(startDate && { startDate: new Date(startDate) }),
        ...(endDate && { endDate: new Date(endDate) }),
        ...(methodology !== undefined && { methodology }),
        ...(targetId && { targetId }),
      },
      include: {
        target: {
          select: {
            id: true,
            name: true,
            type: true,
            url: true,
          },
        },
        createdBy: {
          select: {
            id: true,
            fullName: true,
            email: true,
          },
        },
        _count: {
          select: {
            findings: true,
            reports: true,
            comments: true,
          },
        },
      },
    });

    // Send notifications for status changes
    if (wasCompleted) {
      const notification = notificationTemplates.pentestCompleted(updatedPentest.title, updatedPentest.id);
      await notifyPentestTeam(updatedPentest.id, notification, user.id);
    } else if (wasStarted) {
      const notification = notificationTemplates.pentestStarted(updatedPentest.title, updatedPentest.id);
      await notifyPentestTeam(updatedPentest.id, notification, user.id);
    }

    const responseData = {
      id: updatedPentest.id,
      title: updatedPentest.title,
      description: updatedPentest.description,
      status: updatedPentest.status,
      progress: updatedPentest.progress,
      startDate: updatedPentest.startDate,
      endDate: updatedPentest.endDate,
      methodology: updatedPentest.methodology,
      target: updatedPentest.target,
      createdBy: updatedPentest.createdBy,
      stats: {
        findings: updatedPentest._count.findings,
        reports: updatedPentest._count.reports,
        comments: updatedPentest._count.comments,
      },
      updatedAt: updatedPentest.updatedAt,
    };

    return updatedResponse(responseData, 'Pentest updated successfully');
  } catch (error) {
    console.error('Error updating pentest:', error);
    
    if (error instanceof Error) {
      if (error.message === 'Unauthorized') {
        return unauthorizedResponse();
      }
      if (error.message === 'Forbidden') {
        return forbiddenResponse();
      }
    }
    
    return errorResponse('Failed to update pentest', 500);
  }
}

// DELETE /api/pentests/[id] - Delete pentest
export async function DELETE(request: NextRequest, { params }: RouteParams) {
  try {
    const user = await requirePentester();
    const { id } = params;

    // Check if pentest exists
    const pentest = await prisma.pentest.findFirst({
      where: { 
        id,
        companyId: user.companyId,
      },
      include: {
        _count: {
          select: {
            findings: true,
            reports: true,
          },
        },
      },
    });

    if (!pentest) {
      return notFoundResponse('Pentest');
    }

    // Only creator and admins can delete
    if (pentest.createdById !== user.id && user.role !== 'ADMIN') {
      return forbiddenResponse('Only the creator or admins can delete this pentest');
    }

    // Prevent deletion if there are findings or reports
    if (pentest._count.findings > 0) {
      return errorResponse('Cannot delete pentest with existing findings. Archive it instead.', 400);
    }

    if (pentest._count.reports > 0) {
      return errorResponse('Cannot delete pentest with existing reports. Archive it instead.', 400);
    }

    // Delete pentest (cascade will handle comments)
    await prisma.pentest.delete({
      where: { id },
    });

    return deletedResponse('Pentest deleted successfully');
  } catch (error) {
    console.error('Error deleting pentest:', error);
    
    if (error instanceof Error) {
      if (error.message === 'Unauthorized') {
        return unauthorizedResponse();
      }
      if (error.message === 'Forbidden') {
        return forbiddenResponse();
      }
    }
    
    return errorResponse('Failed to delete pentest', 500);
  }
}
