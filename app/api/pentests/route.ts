import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { requireAuth, requirePentester } from '@/lib/auth-helpers';
import { 
  successResponse, 
  errorResponse, 
  unauthorizedResponse,
  forbiddenResponse,
  createdResponse,
  getPaginationParams,
  getQueryParams,
  getSortParams,
  paginatedResponse
} from '@/lib/api-response';
import { createPentestSchema, filterPentestsSchema } from '@/lib/validations';
import { notificationTemplates, notifyCompanyUsers } from '@/lib/notifications';

// GET /api/pentests - List pentests with filters
export async function GET(request: NextRequest) {
  try {
    const user = await requireAuth();
    const params = getQueryParams(request);
    const { page, limit, skip } = getPaginationParams(params);
    const { sortBy, sortOrder } = getSortParams(params);
    
    // Parse filters
    const filters = {
      status: params.get('status'),
      targetId: params.get('targetId'),
      startDate: params.get('startDate'),
      endDate: params.get('endDate'),
      query: params.get('query'),
    };

    // Build where clause
    const where: any = { companyId: user.companyId };

    if (filters.status) {
      where.status = filters.status;
    }

    if (filters.targetId) {
      where.targetId = filters.targetId;
    }

    if (filters.startDate || filters.endDate) {
      where.startDate = {};
      if (filters.startDate) {
        where.startDate.gte = new Date(filters.startDate);
      }
      if (filters.endDate) {
        where.startDate.lte = new Date(filters.endDate);
      }
    }

    if (filters.query) {
      where.OR = [
        { title: { contains: filters.query, mode: 'insensitive' } },
        { description: { contains: filters.query, mode: 'insensitive' } },
        { methodology: { contains: filters.query, mode: 'insensitive' } },
      ];
    }

    // Get pentests with related data
    const [pentests, total] = await Promise.all([
      prisma.pentest.findMany({
        where,
        skip,
        take: limit,
        orderBy: { [sortBy]: sortOrder },
        include: {
          target: {
            select: {
              id: true,
              name: true,
              type: true,
              url: true,
            },
          },
          createdBy: {
            select: {
              id: true,
              fullName: true,
              email: true,
              avatar: true,
            },
          },
          _count: {
            select: {
              findings: true,
              reports: true,
              comments: true,
            },
          },
        },
      }),
      prisma.pentest.count({ where }),
    ]);

    // Format response
    const formattedPentests = pentests.map(pentest => ({
      id: pentest.id,
      title: pentest.title,
      description: pentest.description,
      status: pentest.status,
      progress: pentest.progress,
      startDate: pentest.startDate,
      endDate: pentest.endDate,
      methodology: pentest.methodology,
      target: pentest.target,
      createdBy: pentest.createdBy,
      stats: {
        findings: pentest._count.findings,
        reports: pentest._count.reports,
        comments: pentest._count.comments,
      },
      createdAt: pentest.createdAt,
      updatedAt: pentest.updatedAt,
    }));

    return paginatedResponse(formattedPentests, page, limit, total);
  } catch (error) {
    console.error('Error fetching pentests:', error);
    
    if (error instanceof Error) {
      if (error.message === 'Unauthorized') {
        return unauthorizedResponse();
      }
    }
    
    return errorResponse('Failed to fetch pentests', 500);
  }
}

// POST /api/pentests - Create new pentest
export async function POST(request: NextRequest) {
  try {
    const user = await requirePentester();
    const body = await request.json();
    
    // Validate input
    const validationResult = createPentestSchema.safeParse(body);
    
    if (!validationResult.success) {
      return errorResponse(validationResult.error, 400);
    }

    const { 
      title, 
      description, 
      status, 
      progress, 
      startDate, 
      endDate, 
      methodology, 
      targetId 
    } = validationResult.data;

    // Verify target exists and belongs to user's company
    const target = await prisma.target.findFirst({
      where: {
        id: targetId,
        companyId: user.companyId,
      },
    });

    if (!target) {
      return errorResponse('Target not found or access denied', 404);
    }

    // Check for overlapping pentests on the same target
    const overlapping = await prisma.pentest.findFirst({
      where: {
        targetId,
        companyId: user.companyId,
        status: { in: ['IN_PROGRESS', 'SCHEDULED'] },
        OR: [
          {
            AND: [
              { startDate: { lte: new Date(startDate) } },
              { endDate: { gte: new Date(startDate) } },
            ],
          },
          {
            AND: [
              { startDate: { lte: new Date(endDate) } },
              { endDate: { gte: new Date(endDate) } },
            ],
          },
        ],
      },
    });

    if (overlapping) {
      return errorResponse('An active pentest already exists for this target in the specified date range', 409);
    }

    // Create pentest
    const pentest = await prisma.pentest.create({
      data: {
        title,
        description,
        status: status || 'SCHEDULED',
        progress: progress || 0,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        methodology,
        targetId,
        companyId: user.companyId,
        createdById: user.id,
      },
      include: {
        target: {
          select: {
            id: true,
            name: true,
            type: true,
            url: true,
          },
        },
        createdBy: {
          select: {
            id: true,
            fullName: true,
            email: true,
          },
        },
      },
    });

    // Send notifications
    const notification = notificationTemplates.pentestCreated(pentest.title, pentest.id);
    await notifyCompanyUsers(user.companyId, notification, user.id);

    const responseData = {
      id: pentest.id,
      title: pentest.title,
      description: pentest.description,
      status: pentest.status,
      progress: pentest.progress,
      startDate: pentest.startDate,
      endDate: pentest.endDate,
      methodology: pentest.methodology,
      target: pentest.target,
      createdBy: pentest.createdBy,
      createdAt: pentest.createdAt,
    };

    return createdResponse(responseData, 'Pentest created successfully');
  } catch (error) {
    console.error('Error creating pentest:', error);
    
    if (error instanceof Error) {
      if (error.message === 'Unauthorized') {
        return unauthorizedResponse();
      }
      if (error.message === 'Forbidden') {
        return forbiddenResponse();
      }
    }
    
    return errorResponse('Failed to create pentest', 500);
  }
}
